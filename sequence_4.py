# -*- coding: utf-8 -*-
"""Sequence 4

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1crNm5p6wzskVwD43Mt6qKEiAyojxVBd6
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, confusion_matrix

# Convert amino acids to numerical values
def encode_sequence(sequence, max_length):
    amino_acids = "ACDEFGHIKLMNPQRSTVWY"
    encoded_sequence = [amino_acids.index(aa) if aa in amino_acids else -1 for aa in sequence]
    if len(encoded_sequence) < max_length:
        encoded_sequence += [-1] * (max_length - len(encoded_sequence))
    return np.array(encoded_sequence).reshape(-1, 1)

# Example sequences

sequence1 ="MQRVNMIMAESPGLITICLLGYLLSAECTVFLDHENANKILNRPKRYNSGKLEEFVQGNLERECMEEKCSFEEAREVFENTERTTEFWKQYVDGDQCESNPCLNGGSCKDDINSYECWCPFGFEGKNCELDVTCNIKNGRCEQFCKNSADNKVVCSCTEGYRLAENQKSCEPAVPFPCGRVSVSQTSKLTRAETVFPDVDYVNSTEAETILDNITQSTQSFNDFTRVVGGEDAKPGQFPWQVVLNGKVDAFCGGSIVNEKWIVTAAHCVETGVKITVVAGEHNIEETEHTEQKRNVIRIIPHHNYNAAINKYNHDIALLELDEPLVLNSYVTPICIADKEYTNIFLKFGSGYVSGWGRVFHKGRSALVLQYLRVPLVDRATCLRSTKFTIYNNMFCAGFHEGGRDSCQGDSGGPHVTEVEGTSFLTGIISWGEECAMKGKYGIYTKVSRYVNWIKEKTKLT"
sequence2="MQIELSTCFFLCLLRFCFSATRRYYLGAVELSWDYMQSDLGELPVDARFPPRVPKSFPFNTSVVYKKTLFVEFTDHLFNIAKPRPPWMGLLGPTIQAEVYDTVVITLKNMASHPVSLHAVGVSYWKASEGAEYDDQTSQREKEDDKVFPGGSHTYVWQVLKENGPMASDPLCLTYSYLSHVDLVKDLNSGLIGALLVCREGSLAKEKTQTLHKFILLFAVFDEGKSWHSETKNSLMQDRDAASARAWPKMHTVNGYVNRSLPGLIGCHRKSVYWHVIGMGTTPEVHSIFLEGHTFLVRNHRQASLEISPITFLTAQTLLMDLGQFLLFCHISSHQHDGMEAYVKVDSCPEEPQLRMKNNEEAEDYDDDLTDSEMDVVRFDDDNSPSFIQIRSVAKKHPKTWVHYIAAEEEDWDYAPLVLAPDDRSYKSQYLNNGPQRIGRKYKKVRFMAYTDETFKTREAIQHESGILGPLLYGEVGDTLLIIFKNQASRPYNIYPHGITDVRPLYSRRLPKGVKHLKDFPILPGEIFKYKWTVTVEDGPTKSDPRCLTRYYSSFVNMERDLASGLIGPLLICYKESVDQRGNQIMSDKRNVILFSVFDENRSWYLTENIQRFLPNPAGVQLEDPEFQASNIMHSINGYVFDSLQLSVCLHEVAYWYILSIGAQTDFLSVFFSGYTFKHKMVYEDTLTLFPFSGETVFMSMENPGLWILGCHNSDFRNRGMTALLKVSSCDKNTGDYYEDSYEDISAYLLSKNNAIEPRSFSQNSRHPSTRQKQFNATTIPENDIEKTDPWFAHRTPMPKIQNVSSSDLLMLLRQSPTPHGLSLSDLQEAKYETFSDDPSPGAIDSNNSLSEMTHFRPQLHHSGDMVFTPESGLQLRLNEKLGTTAATELKKLDFKVSSTSNNLISTIPSDNLAAGTDNTSSLGPPSMPVHYDSQLDTTLFGKKSSPLTESGGPLSLSEENNDSKLLESGLMNSQESSWGKNVSSTESGRLFKGKRAHGPALLTKDNALFKVSISLLKTNKTSNNSATNRKTHIDGPSLLIENSPSVWQNILESDTEFKKVTPLIHDRMLMDKNATALRLNHMSNKTTSSKNMEMVQQKKEGPIPPDAQNPDMSFFKMLFLPESARWIQRTHGKNSLNSGQGPSPKQLVSLGPEKSVEGQNFLSEKNKVVVGKGEFTKDVGLKEMVFPSSRNLFLTNLDNLHENNTHNQEKKIQEEIEKKETLIQENVVLPQIHTVTGTKNFMKNLFLLSTRQNVEGSYDGAYAPVLQDFRSLNDSTNRTKKHTAHFSKKGEEENLEGLGNQTKQIVEKYACTTRISPNTSQQNFVTQRSKRALKQFRLPLEETELEKRIIVDDTSTQWSKNMKHLTPSTLTQIDYNEKEKGAITQSPLSDCLTRSHSIPQANRSPLPIAKVSSFPSIRPIYLTRVLFQDNSSHLPAASYRKKDSGVQESSHFLQGAKKNNLSLAILTLEMTGDQREVGSLGTSATNSVTYKKVENTVLPKPDLPKTSGKVELLPKVHIYQKDLFPTETSNGSPGHLDLVEGSLLQGTEGAIKWNEANRPGKVPFLRVATESSAKTPSKLLDPLAWDNHYGTQIPKEEWKSQEKSPEKTAFKKKDTILSLNACESNHAIAAINEGQNKPEIEVTWAKQGRTERLCSQNPPVLKRHQREITRTTLQSDQEEIDYDDTISVEMKKEDFDIYDEDENQSPRSFQKKTRHYFIAAVERLWDYGMSSSPHVLRNRAQSGSVPQFKKVVFQEFTDGSFTQPLYRGELNEHLGLLGPYIRAEVEDNIMVTFRNQASRPYSFYSSLISYEEDQRQGAEPRKNFVKPNETKTYFWKVQHHMAPTKDEFDCKAWAYFSDVDLEKDVHSGLIGPLLVCHTNTLNPAHGRQVTVQEFALFFTIFDETKSWYFTENMERNCRAPCNIQMEDPTFKENYRFHAINGYIMDTLPGLVMAQDQRIRWYLLSMGSNENIHSIHFSGHVFTVRKKEEYKMALYNLYPGVFETVEMLPSKAGIWRVECLIGEHLHAGMSTLFLVYSNKCQTPLGMASGHIRDFQITASGQYGQWAPKLARLHYSGSINAWSTKEPFSWIKVDLLAPMIIHGIKTQGARQKFSSLYISQFIIMYSLDGKKWQTYRGNSTGTLMVFFGNVDSSGIKHNIFNPPIIARYIRLHPTHYSIRSTLRMELMGCDLNSCSMPLGMESKAISDAQITASSYFTNMFATWSPSKARLHLQGRSNAWRPQVNNPKEWLQVDFQKTMKVTGVTTQGVKSLLTSMYVKEFLISSSQDGHQWTLFFQNGKVKVFQGNQDSFTPVVNSLDPPLLTRYLRIHPQSWVHQIALRMEVLGCEAQDLY"
# Determine maximum sequence length
max_length = max(len(sequence1), len(sequence2))

# Encode sequences
encoded_sequence1 = encode_sequence(sequence1, max_length)
encoded_sequence2 = encode_sequence(sequence2, max_length)

# Find differences
sequence_diff = (encoded_sequence1 != encoded_sequence2).astype(int)

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(encoded_sequence1, sequence_diff, test_size=0.3, random_state=42)

# Train classifier
clf = RandomForestClassifier(n_estimators=100, random_state=42)
clf.fit(X_train, y_train)

# Predict
y_pred = clf.predict(X_test)

# Evaluate
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)

# Confusion matrix
conf_matrix = confusion_matrix(y_test, y_pred)

# Visualization
plt.figure(figsize=(10, 7))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()



import seaborn as sns
import matplotlib.pyplot as plt
absolute_diff = np.abs(encoded_sequence1 - encoded_sequence2)

plt.figure(figsize=(15, 6))
plt.scatter(range(max_length), absolute_diff.flatten(), color='black', alpha=0.6)
plt.xlabel('Position in Sequence', fontsize=12)
plt.ylabel('Absolute Amino Acid Difference', fontsize=12)
plt.title('Absolute Amino Acid Differences Between Sequences', fontsize=14)
plt.xticks(fontsize=8)
plt.yticks(fontsize=8)
plt.tight_layout()
plt.show()



import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, confusion_matrix

# Convert amino acids to numerical values
def encode_sequence(sequence, max_length):
    amino_acids = "ACDEFGHIKLMNPQRSTVWY"
    encoded_sequence = [amino_acids.index(aa) if aa in amino_acids else -1 for aa in sequence]
    if len(encoded_sequence) < max_length:
        encoded_sequence += [-1] * (max_length - len(encoded_sequence))
    return np.array(encoded_sequence).reshape(-1, 1)

# Example sequences
sequence1 ="MQRVNMIMAESPGLITICLLGYLLSAECTVFLDHENANKILNRPKRYNSGKLEEFVQGNLERECMEEKCSFEEAREVFENTERTTEFWKQYVDGDQCESNPCLNGGSCKDDINSYECWCPFGFEGKNCELDVTCNIKNGRCEQFCKNSADNKVVCSCTEGYRLAENQKSCEPAVPFPCGRVSVSQTSKLTRAETVFPDVDYVNSTEAETILDNITQSTQSFNDFTRVVGGEDAKPGQFPWQVVLNGKVDAFCGGSIVNEKWIVTAAHCVETGVKITVVAGEHNIEETEHTEQKRNVIRIIPHHNYNAAINKYNHDIALLELDEPLVLNSYVTPICIADKEYTNIFLKFGSGYVSGWGRVFHKGRSALVLQYLRVPLVDRATCLRSTKFTIYNNMFCAGFHEGGRDSCQGDSGGPHVTEVEGTSFLTGIISWGEECAMKGKYGIYTKVSRYVNWIKEKTKLT"
sequence2="MQIELSTCFFLCLLRFCFSATRRYYLGAVELSWDYMQSDLGELPVDARFPPRVPKSFPFNTSVVYKKTLFVEFTDHLFNIAKPRPPWMGLLGPTIQAEVYDTVVITLKNMASHPVSLHAVGVSYWKASEGAEYDDQTSQREKEDDKVFPGGSHTYVWQVLKENGPMASDPLCLTYSYLSHVDLVKDLNSGLIGALLVCREGSLAKEKTQTLHKFILLFAVFDEGKSWHSETKNSLMQDRDAASARAWPKMHTVNGYVNRSLPGLIGCHRKSVYWHVIGMGTTPEVHSIFLEGHTFLVRNHRQASLEISPITFLTAQTLLMDLGQFLLFCHISSHQHDGMEAYVKVDSCPEEPQLRMKNNEEAEDYDDDLTDSEMDVVRFDDDNSPSFIQIRSVAKKHPKTWVHYIAAEEEDWDYAPLVLAPDDRSYKSQYLNNGPQRIGRKYKKVRFMAYTDETFKTREAIQHESGILGPLLYGEVGDTLLIIFKNQASRPYNIYPHGITDVRPLYSRRLPKGVKHLKDFPILPGEIFKYKWTVTVEDGPTKSDPRCLTRYYSSFVNMERDLASGLIGPLLICYKESVDQRGNQIMSDKRNVILFSVFDENRSWYLTENIQRFLPNPAGVQLEDPEFQASNIMHSINGYVFDSLQLSVCLHEVAYWYILSIGAQTDFLSVFFSGYTFKHKMVYEDTLTLFPFSGETVFMSMENPGLWILGCHNSDFRNRGMTALLKVSSCDKNTGDYYEDSYEDISAYLLSKNNAIEPRSFSQNSRHPSTRQKQFNATTIPENDIEKTDPWFAHRTPMPKIQNVSSSDLLMLLRQSPTPHGLSLSDLQEAKYETFSDDPSPGAIDSNNSLSEMTHFRPQLHHSGDMVFTPESGLQLRLNEKLGTTAATELKKLDFKVSSTSNNLISTIPSDNLAAGTDNTSSLGPPSMPVHYDSQLDTTLFGKKSSPLTESGGPLSLSEENNDSKLLESGLMNSQESSWGKNVSSTESGRLFKGKRAHGPALLTKDNALFKVSISLLKTNKTSNNSATNRKTHIDGPSLLIENSPSVWQNILESDTEFKKVTPLIHDRMLMDKNATALRLNHMSNKTTSSKNMEMVQQKKEGPIPPDAQNPDMSFFKMLFLPESARWIQRTHGKNSLNSGQGPSPKQLVSLGPEKSVEGQNFLSEKNKVVVGKGEFTKDVGLKEMVFPSSRNLFLTNLDNLHENNTHNQEKKIQEEIEKKETLIQENVVLPQIHTVTGTKNFMKNLFLLSTRQNVEGSYDGAYAPVLQDFRSLNDSTNRTKKHTAHFSKKGEEENLEGLGNQTKQIVEKYACTTRISPNTSQQNFVTQRSKRALKQFRLPLEETELEKRIIVDDTSTQWSKNMKHLTPSTLTQIDYNEKEKGAITQSPLSDCLTRSHSIPQANRSPLPIAKVSSFPSIRPIYLTRVLFQDNSSHLPAASYRKKDSGVQESSHFLQGAKKNNLSLAILTLEMTGDQREVGSLGTSATNSVTYKKVENTVLPKPDLPKTSGKVELLPKVHIYQKDLFPTETSNGSPGHLDLVEGSLLQGTEGAIKWNEANRPGKVPFLRVATESSAKTPSKLLDPLAWDNHYGTQIPKEEWKSQEKSPEKTAFKKKDTILSLNACESNHAIAAINEGQNKPEIEVTWAKQGRTERLCSQNPPVLKRHQREITRTTLQSDQEEIDYDDTISVEMKKEDFDIYDEDENQSPRSFQKKTRHYFIAAVERLWDYGMSSSPHVLRNRAQSGSVPQFKKVVFQEFTDGSFTQPLYRGELNEHLGLLGPYIRAEVEDNIMVTFRNQASRPYSFYSSLISYEEDQRQGAEPRKNFVKPNETKTYFWKVQHHMAPTKDEFDCKAWAYFSDVDLEKDVHSGLIGPLLVCHTNTLNPAHGRQVTVQEFALFFTIFDETKSWYFTENMERNCRAPCNIQMEDPTFKENYRFHAINGYIMDTLPGLVMAQDQRIRWYLLSMGSNENIHSIHFSGHVFTVRKKEEYKMALYNLYPGVFETVEMLPSKAGIWRVECLIGEHLHAGMSTLFLVYSNKCQTPLGMASGHIRDFQITASGQYGQWAPKLARLHYSGSINAWSTKEPFSWIKVDLLAPMIIHGIKTQGARQKFSSLYISQFIIMYSLDGKKWQTYRGNSTGTLMVFFGNVDSSGIKHNIFNPPIIARYIRLHPTHYSIRSTLRMELMGCDLNSCSMPLGMESKAISDAQITASSYFTNMFATWSPSKARLHLQGRSNAWRPQVNNPKEWLQVDFQKTMKVTGVTTQGVKSLLTSMYVKEFLISSSQDGHQWTLFFQNGKVKVFQGNQDSFTPVVNSLDPPLLTRYLRIHPQSWVHQIALRMEVLGCEAQDLY"

# Determine maximum sequence length
max_length = max(len(sequence1), len(sequence2))

# Encode sequences
encoded_sequence1 = encode_sequence(sequence1, max_length)
encoded_sequence2 = encode_sequence(sequence2, max_length)

# Find differences
sequence_diff = (encoded_sequence1 != encoded_sequence2).astype(int)

# Prepare data for classification
X = np.vstack((encoded_sequence1.flatten(), encoded_sequence2.flatten())).T
y = sequence_diff.flatten()

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Train decision tree classifier
clf = DecisionTreeClassifier(random_state=42)
clf.fit(X_train, y_train)

# Predict
y_pred = clf.predict(X_test)

# Evaluate
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)

# Confusion matrix
conf_matrix = confusion_matrix(y_test, y_pred)

# Visualization
plt.figure(figsize=(10, 7))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, confusion_matrix

# Convert amino acids to numerical values
def encode_sequence(sequence, max_length):
    amino_acids = "ACDEFGHIKLMNPQRSTVWY"
    encoded_sequence = [amino_acids.index(aa) if aa in amino_acids else -1 for aa in sequence]
    if len(encoded_sequence) < max_length:
        encoded_sequence += [-1] * (max_length - len(encoded_sequence))
    return np.array(encoded_sequence).reshape(-1, 1)

# Example sequences
sequence1 ="MQRVNMIMAESPGLITICLLGYLLSAECTVFLDHENANKILNRPKRYNSGKLEEFVQGNLERECMEEKCSFEEAREVFENTERTTEFWKQYVDGDQCESNPCLNGGSCKDDINSYECWCPFGFEGKNCELDVTCNIKNGRCEQFCKNSADNKVVCSCTEGYRLAENQKSCEPAVPFPCGRVSVSQTSKLTRAETVFPDVDYVNSTEAETILDNITQSTQSFNDFTRVVGGEDAKPGQFPWQVVLNGKVDAFCGGSIVNEKWIVTAAHCVETGVKITVVAGEHNIEETEHTEQKRNVIRIIPHHNYNAAINKYNHDIALLELDEPLVLNSYVTPICIADKEYTNIFLKFGSGYVSGWGRVFHKGRSALVLQYLRVPLVDRATCLRSTKFTIYNNMFCAGFHEGGRDSCQGDSGGPHVTEVEGTSFLTGIISWGEECAMKGKYGIYTKVSRYVNWIKEKTKLT"
sequence2="MQIELSTCFFLCLLRFCFSATRRYYLGAVELSWDYMQSDLGELPVDARFPPRVPKSFPFNTSVVYKKTLFVEFTDHLFNIAKPRPPWMGLLGPTIQAEVYDTVVITLKNMASHPVSLHAVGVSYWKASEGAEYDDQTSQREKEDDKVFPGGSHTYVWQVLKENGPMASDPLCLTYSYLSHVDLVKDLNSGLIGALLVCREGSLAKEKTQTLHKFILLFAVFDEGKSWHSETKNSLMQDRDAASARAWPKMHTVNGYVNRSLPGLIGCHRKSVYWHVIGMGTTPEVHSIFLEGHTFLVRNHRQASLEISPITFLTAQTLLMDLGQFLLFCHISSHQHDGMEAYVKVDSCPEEPQLRMKNNEEAEDYDDDLTDSEMDVVRFDDDNSPSFIQIRSVAKKHPKTWVHYIAAEEEDWDYAPLVLAPDDRSYKSQYLNNGPQRIGRKYKKVRFMAYTDETFKTREAIQHESGILGPLLYGEVGDTLLIIFKNQASRPYNIYPHGITDVRPLYSRRLPKGVKHLKDFPILPGEIFKYKWTVTVEDGPTKSDPRCLTRYYSSFVNMERDLASGLIGPLLICYKESVDQRGNQIMSDKRNVILFSVFDENRSWYLTENIQRFLPNPAGVQLEDPEFQASNIMHSINGYVFDSLQLSVCLHEVAYWYILSIGAQTDFLSVFFSGYTFKHKMVYEDTLTLFPFSGETVFMSMENPGLWILGCHNSDFRNRGMTALLKVSSCDKNTGDYYEDSYEDISAYLLSKNNAIEPRSFSQNSRHPSTRQKQFNATTIPENDIEKTDPWFAHRTPMPKIQNVSSSDLLMLLRQSPTPHGLSLSDLQEAKYETFSDDPSPGAIDSNNSLSEMTHFRPQLHHSGDMVFTPESGLQLRLNEKLGTTAATELKKLDFKVSSTSNNLISTIPSDNLAAGTDNTSSLGPPSMPVHYDSQLDTTLFGKKSSPLTESGGPLSLSEENNDSKLLESGLMNSQESSWGKNVSSTESGRLFKGKRAHGPALLTKDNALFKVSISLLKTNKTSNNSATNRKTHIDGPSLLIENSPSVWQNILESDTEFKKVTPLIHDRMLMDKNATALRLNHMSNKTTSSKNMEMVQQKKEGPIPPDAQNPDMSFFKMLFLPESARWIQRTHGKNSLNSGQGPSPKQLVSLGPEKSVEGQNFLSEKNKVVVGKGEFTKDVGLKEMVFPSSRNLFLTNLDNLHENNTHNQEKKIQEEIEKKETLIQENVVLPQIHTVTGTKNFMKNLFLLSTRQNVEGSYDGAYAPVLQDFRSLNDSTNRTKKHTAHFSKKGEEENLEGLGNQTKQIVEKYACTTRISPNTSQQNFVTQRSKRALKQFRLPLEETELEKRIIVDDTSTQWSKNMKHLTPSTLTQIDYNEKEKGAITQSPLSDCLTRSHSIPQANRSPLPIAKVSSFPSIRPIYLTRVLFQDNSSHLPAASYRKKDSGVQESSHFLQGAKKNNLSLAILTLEMTGDQREVGSLGTSATNSVTYKKVENTVLPKPDLPKTSGKVELLPKVHIYQKDLFPTETSNGSPGHLDLVEGSLLQGTEGAIKWNEANRPGKVPFLRVATESSAKTPSKLLDPLAWDNHYGTQIPKEEWKSQEKSPEKTAFKKKDTILSLNACESNHAIAAINEGQNKPEIEVTWAKQGRTERLCSQNPPVLKRHQREITRTTLQSDQEEIDYDDTISVEMKKEDFDIYDEDENQSPRSFQKKTRHYFIAAVERLWDYGMSSSPHVLRNRAQSGSVPQFKKVVFQEFTDGSFTQPLYRGELNEHLGLLGPYIRAEVEDNIMVTFRNQASRPYSFYSSLISYEEDQRQGAEPRKNFVKPNETKTYFWKVQHHMAPTKDEFDCKAWAYFSDVDLEKDVHSGLIGPLLVCHTNTLNPAHGRQVTVQEFALFFTIFDETKSWYFTENMERNCRAPCNIQMEDPTFKENYRFHAINGYIMDTLPGLVMAQDQRIRWYLLSMGSNENIHSIHFSGHVFTVRKKEEYKMALYNLYPGVFETVEMLPSKAGIWRVECLIGEHLHAGMSTLFLVYSNKCQTPLGMASGHIRDFQITASGQYGQWAPKLARLHYSGSINAWSTKEPFSWIKVDLLAPMIIHGIKTQGARQKFSSLYISQFIIMYSLDGKKWQTYRGNSTGTLMVFFGNVDSSGIKHNIFNPPIIARYIRLHPTHYSIRSTLRMELMGCDLNSCSMPLGMESKAISDAQITASSYFTNMFATWSPSKARLHLQGRSNAWRPQVNNPKEWLQVDFQKTMKVTGVTTQGVKSLLTSMYVKEFLISSSQDGHQWTLFFQNGKVKVFQGNQDSFTPVVNSLDPPLLTRYLRIHPQSWVHQIALRMEVLGCEAQDLY"


# Determine maximum sequence length
max_length = max(len(sequence1), len(sequence2))

# Encode sequences
encoded_sequence1 = encode_sequence(sequence1, max_length)
encoded_sequence2 = encode_sequence(sequence2, max_length)

# Find differences
sequence_diff = (encoded_sequence1 != encoded_sequence2).astype(int)

# Prepare data for classification
X = np.vstack((encoded_sequence1.flatten(), encoded_sequence2.flatten())).T
y = sequence_diff.flatten()

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Train SVM classifier
clf = SVC(random_state=42)
clf.fit(X_train, y_train)

# Predict
y_pred = clf.predict(X_test)

# Evaluate
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)

# Confusion matrix
conf_matrix = confusion_matrix(y_test, y_pred)

# Visualization
plt.figure(figsize=(10, 7))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()

# # Scatter plot to visualize some aspect of the data
# plt.figure(figsize=(10, 7))
# plt.scatter(X[:, 0], X[:, 1], c=y, cmap='viridis', alpha=0.6, edgecolors='w', linewidth=0.5)
# plt.xlabel('Encoded Sequence Position 1')
# plt.ylabel('Encoded Sequence Position 2')
# plt.title('Scatter Plot of Encoded Sequences')
# plt.show()



import pandas as pd

# Confusion matrix data
decision_tree_data = [
    [0.97, 0.66, 0.85, 0.74, 0.98],
    [0.95, 0.66, 0.85, 0.74, 0.98],
    [0.91, 0.28, 0.22, 0.78, 0.96],
    [0.98, 0.83, 0.58, 0.68, 0.99]
]

random_forest_data = [
    [0.95, 0, 0, 0, 0.95],
    [0.95, 0, 0, 0, 0.95],
    [0.95, 0, 0, 0, 0.95],
    [0.98, 0, 0, 0, 0.98]
]

svm_data = [
    [0.95, 0, 0, 0, 0.95],
    [0.95, 0, 0, 0, 0.95],
    [0.95, 0, 0, 0, 0.95],
    [0.98, 0, 0, 0, 0.98]

]

# Create DataFrames
df_decision_tree = pd.DataFrame(decision_tree_data, columns=['Accuracy', 'Precision', 'Recall', 'F1 Score', 'Specificity'])
df_random_forest = pd.DataFrame(random_forest_data, columns=['Accuracy', 'Precision', 'Recall', 'F1 Score', 'Specificity'])
df_svm = pd.DataFrame(svm_data, columns=['Accuracy', 'Precision', 'Recall', 'F1 Score', 'Specificity'])

# Add classifier column
df_decision_tree['Classifier'] = 'Decision Tree'
df_random_forest['Classifier'] = 'Random Forest'
df_svm['Classifier'] = 'SVM'

# Concatenate DataFrames
df = pd.concat([df_decision_tree, df_random_forest, df_svm], ignore_index=True)

# Print the resulting DataFrame
print(df)



import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Confusion matrix data (assuming these are recorded over time)
decision_tree_data = [
    [0.97, 0.66, 0.85, 0.74, 0.98],
    [0.95, 0.66, 0.85, 0.74, 0.98],
    [0.91, 0.28, 0.22, 0.78, 0.96],
    [0.98, 0.83, 0.58, 0.68, 0.99]
]

random_forest_data = [
    [0.95, 0, 0, 0, 0.95],
    [0.95, 0, 0, 0, 0.95],
    [0.95, 0, 0, 0, 0.95],
    [0.98, 0, 0, 0, 0.98]
]

svm_data = [
    [0.95, 0, 0, 0, 0.95],
    [0.95, 0, 0, 0, 0.95],
    [0.95, 0, 0, 0, 0.95],
    [0.98, 0, 0, 0, 0.98]

]

# Create DataFrames
df_decision_tree = pd.DataFrame(decision_tree_data, columns=['Accuracy', 'Precision', 'Recall', 'F1 Score', 'Specificity'])
df_random_forest = pd.DataFrame(random_forest_data, columns=['Accuracy', 'Precision', 'Recall', 'F1 Score', 'Specificity'])
df_svm = pd.DataFrame(svm_data, columns=['Accuracy', 'Precision', 'Recall', 'F1 Score', 'Specificity'])

# Add classifier column
df_decision_tree['Classifier'] = 'Decision Tree'
df_random_forest['Classifier'] = 'Random Forest'
df_svm['Classifier'] = 'SVM'

# Add time points
df_decision_tree['Time'] = range(1, len(df_decision_tree) + 1)
df_random_forest['Time'] = range(1, len(df_random_forest) + 1)
df_svm['Time'] = range(1, len(df_svm) + 1)

# Concatenate DataFrames
df = pd.concat([df_decision_tree, df_random_forest, df_svm], ignore_index=True)

# Melt the dataframe for easier plotting
df_melted = df.melt(id_vars=['Time', 'Classifier'], value_vars=['Accuracy', 'Precision', 'Recall', 'F1 Score', 'Specificity'],
                    var_name='Metric', value_name='Value')

# Plot
plt.figure(figsize=(14, 8))
sns.lineplot(data=df_melted, x='Time', y='Value', hue='Classifier', style='Metric', markers=True, dashes=False)
plt.title('Performance Metrics Over Time for Different Classifiers')
plt.xlabel('Time')
plt.ylabel('Metric Value')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(True)
plt.show()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LinearRegression

# Confusion matrix data
decision_tree_data = [
    [0.97, 0.66, 0.85, 0.74, 0.98],
    [0.95, 0.66, 0.85, 0.74, 0.98],
    [0.91, 0.28, 0.22, 0.78, 0.96],
    [0.98, 0.83, 0.58, 0.68, 0.99]
]

random_forest_data = [
    [0.95, 0, 0, 0, 0.95],
    [0.95, 0, 0, 0, 0.95],
    [0.95, 0, 0, 0, 0.95],
    [0.98, 0, 0, 0, 0.98]
]

svm_data = [
    [0.95, 0, 0, 0, 0.95],
    [0.95, 0, 0, 0, 0.95],
    [0.95, 0, 0, 0, 0.95],
    [0.98, 0, 0, 0, 0.98]
]

# Create DataFrames
df_decision_tree = pd.DataFrame(decision_tree_data, columns=['Accuracy', 'Precision', 'Recall', 'F1 Score', 'Specificity'])
df_random_forest = pd.DataFrame(random_forest_data, columns=['Accuracy', 'Precision', 'Recall', 'F1 Score', 'Specificity'])
df_svm = pd.DataFrame(svm_data, columns=['Accuracy', 'Precision', 'Recall', 'F1 Score', 'Specificity'])

# Add classifier column
df_decision_tree['Classifier'] = 'Decision Tree'
df_random_forest['Classifier'] = 'Random Forest'
df_svm['Classifier'] = 'SVM'

# Concatenate DataFrames
df = pd.concat([df_decision_tree, df_random_forest, df_svm], ignore_index=True)

# Melt the dataframe for easier plotting
df_melted = df.melt(id_vars=['Classifier'], value_vars=['Accuracy', 'Precision', 'Recall', 'F1 Score', 'Specificity'],
                    var_name='Metric', value_name='Value')

# Plot
fig, axes = plt.subplots(5, 1, figsize=(14, 20), sharex=True)
metrics = ['Accuracy', 'Precision', 'Recall', 'F1 Score', 'Specificity']

for i, metric in enumerate(metrics):
    ax = axes[i]
    sns.scatterplot(data=df_melted[df_melted['Metric'] == metric], x='Classifier', y='Value', hue='Classifier', ax=ax, palette='deep', s=100)

    for classifier in df['Classifier'].unique():
        # Subset the data
        df_subset = df_melted[(df_melted['Classifier'] == classifier) & (df_melted['Metric'] == metric)]
        X = np.arange(len(df_subset)).reshape(-1, 1)  # X values are just indices
        y = df_subset['Value'].values

        # Fit linear regression
        model = LinearRegression()
        model.fit(X, y)

        # Predict
        y_pred = model.predict(X)

        # Plot the regression line
        ax.plot(df_subset['Classifier'], y_pred, label=f'{classifier} - {metric}', linestyle='--')

    ax.set_title(f'Regression Lines for {metric} for Different Classifiers')
    ax.set_ylabel(f'{metric} Value')
    ax.legend(loc='upper left')
    ax.grid(True)

axes[-1].set_xlabel('Classifier')
plt.tight_layout()
plt.show()